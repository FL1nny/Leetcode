给你一个整数 numberOfUsers 表示用户总数，另有一个大小为 n x 3 的数组 events 。

每个 events[i] 都属于下述两种类型之一：

消息事件（Message Event）：["MESSAGE", "timestampi", "mentions_stringi"]
事件表示在 timestampi 时，一组用户被消息提及。
mentions_stringi 字符串包含下述标识符之一：
id<number>：其中 <number> 是一个区间 [0,numberOfUsers - 1] 内的整数。可以用单个空格分隔 多个 id ，并且 id 可能重复。此外，这种形式可以提及离线用户。
ALL：提及 所有 用户。
HERE：提及所有 在线 用户。
离线事件（Offline Event）：["OFFLINE", "timestampi", "idi"]
事件表示用户 idi 在 timestampi 时变为离线状态 60 个单位时间。用户会在 timestampi + 60 时自动再次上线。
返回数组 mentions ，其中 mentions[i] 表示  id 为  i 的用户在所有 MESSAGE 事件中被提及的次数。

最初所有用户都处于在线状态，并且如果某个用户离线或者重新上线，其对应的状态变更将会在所有相同时间发生的消息事件之前进行处理和同步。

注意 在单条消息中，同一个用户可能会被提及多次。每次提及都需要被 分别 统计。



class Solution {
public:
    vector<int> countMentions(int numberOfUsers, vector<vector<string>>& events) {
        vector<int> count(numberOfUsers);
        vector<int> next_onlline_time(numberOfUsers);//某用户下次在线时间
        sort(events.begin(),events.end(),[&](const vector<string> &lth, const vector<string> &rth){//sort(start,end,排序方法)
            int lth_timestamp = stoi(lth[1]);
            //按时间戳排序，时间戳为数组中每行第二个元素也即events[1](从0开始)
            //lth(left hand)与rth(right hand)传入的不是events而是events[i]与events[j]  
            //stoi将字符转为int型以便比较否则会出现'100'<'50' 因为'1'<'5'
            int rth_timestamp = stoi(rth[1]);
            if(lth_timestamp != rth_timestamp){
                return lth_timestamp < rth_timestamp;//若l < r返回true否则返回false => swap(l,r),实现升序排列
            }
            if(rth[0] == "OFFLINE"){
                return false;//相同时间戳下OFFLINE排序在前面 false => rth < lth
            }
            return true;//comp(a,b) == true =>a排序在b前面
        });
        for(auto &&event : events){

        //从event[0][]循环到event[numberOfUsers-1][] 
        //范围for循环for(declaration : expression) <==>
        // {
        //     auto &&_range = expression    
        //     for(auto __begin = begin(__range), __end = end(__range);
        //         __begin != __end; ++__begin) {
        //         declaration = *__begin;  // ← *__begin 是容器的元素
        //     }
        // }
        //外层多行 内层每行多列 -> 遍历外层得到各行

            int cur_time = stoi(event[1]);
            if(event[0] == "MESSAGE"){
                if(event[2] == "ALL"){
                    for(int i = 0; i < numberOfUsers; i++){
                        count[i]++;
                    }
                }
                else if(event[2] == "HERE"){
                    for(int i = 0; i < numberOfUsers; i++){
                        if(next_onlline_time[i] <= cur_time){//若某用户下一在线时间小于当前时间则该用户已不再离线
                            count[i]++;
                        }
                    }
                }
                else{                                       //id<number>情况
                    int idx = 0;
                    for(int i = 0; i < event[2].size(); i++){
                        if(isdigit(event[2][i])){           //isdigit(a)检验a中每一个字符是否为十进制数字
                            idx = idx * 10 + (event[2][i] - '0');
                            //idx * 10 <==> idx << 1(十进制左移一位)  
                            //如users123在筛选掉非十进制的'u''s''e''r'后 idx = 0 * 10 + ('1'-'0') => idx = 1
                            //idx = 1 * 10 +('2'-'0') => idx = 12
                            //(event[2][i] - '0')将event中非十进制字段删除后剩余十进制字符串与字符'0'相减所得ASCII码相对距离隐式转换为int型
                        }
                        if(i + 1 == event[2].size() || event[2][i+1] == ' '){
                            count[idx]++;
                            idx = 0;                        //若有空格或到最大长度则中断并使对应count[id] += 1
                        }
                    }
                }
            }
            else{                                           //OFFLINE -> 进入离线 => 更新用户sb下一次上线时间（next_online_time）
                int sb = stoi(event[2]);
                next_onlline_time[sb] = cur_time + 60;
            }
        }
        return count;
    }
};
