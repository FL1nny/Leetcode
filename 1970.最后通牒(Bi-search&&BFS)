class Solution {
private:
    static constexpr int dirs[4][2] = {{-1 , 0} , {1 , 0} , {0 , -1} , {0 , 1}};//上下左右
public:
    int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
        int l = 0, r = row * col,  ans = 0;
        while(l <= r){
            int mid = (l + r) >> 1;//若最晚k天可到达，那么 ∀x < k均可到达 且 ∀x > k均无法到达 =>有序可二分查找
        vector<vector<int>> grid(row , vector<int> (col,1));//grid[row.size()][col.size()#第二维度每个值初始化为一 即陆地]
            for(int i = 0 ; i < mid; i++){
                grid[cells[i][0] - 1][cells[i][1] - 1] = 0;//cells[i][0]代表第i天的行号  cells[i][1]代表第i天的列号 
                                                           //下标从1开始 -1 转化为0-base索引
            }

        queue<pair<int , int>> q;//BFS初始化
        for(int i = 0 ; i < col; i++){
            if(grid[0][i]){//遍历第一行的每一列 若为陆地则执行：
                q.emplace(0 , i);//在队列q内构造pair(0 , i)并插入（构造+入队操作） 入队:a = pair(0 , i);   q.push(a);
                grid[0][i] = 0;
            }
        }
        bool flag = 0;
        while(!q.empty()){
            auto [x,y] = q.front();//q.front返回队列前端元素，将第一个元素的行赋值给x,第一个元素的列赋值给y并通过pop出队该元素
            q.pop();
            for(int d = 0; d < 4; d++){
                int nx = x + dirs[d][0];
                int ny = y + dirs[d][1];
                if(nx >= 0 && nx < row && ny >= 0 && ny < col && grid[nx][ny]){
                    if(nx == row - 1){
                        flag = true;
                        break;
                    }
                    q.emplace(nx , ny);
                    grid[nx][ny] = 0;//入队(nx,ny),邻居节点标记为已访问
                }
            } //搜索上下左右 若有可行格子将其入队
        }
        if(flag){
            ans = mid;
            l = mid + 1;
        }
        else{
            r = mid - 1;
        }
        }
        return ans;
    }
};
